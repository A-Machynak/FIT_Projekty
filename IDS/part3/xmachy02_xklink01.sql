-- Poznámka:
-- Skript neodpovídá ER diagramu - byly provedeny (opraveny) některé části, které by vedly ke "špatnému" řešení:
-- - tickets <-> patches jsou nyní ve vztahu M:N
--   Ticket může být vyřešen několika patch-y a patch
--   může řešit několik ticketů (duplicitní oznámení od uživatelů o bugu)
-- - Opraveno "Identifikujici vazba ma chybnou nasobnost (asi opacne)"
-- - Opraveno "Uzivatel/Programator.programovaci_jazky je nasobny (neni atomicky atribut)"
-- - Opraveno "Chybi generalizace/specializace" (users/programmers)

-- - Opraveno "creator_programmer_id"(references programmers) na "creator_id"(references users) 
--   Uživatelé můžou také vytvářet patche, programátoři je musí pouze kontrolovat

-- Drop
DROP TABLE ticket_patch;
DROP TABLE bug_message;
DROP TABLE patch_module;
DROP TABLE module_bug;
DROP TABLE ticket_bug;
DROP TABLE vulnerability;
DROP TABLE bugs;
DROP TABLE module_language;
DROP TABLE modules;
DROP TABLE tickets;
DROP TABLE patches;
DROP TABLE user_language;
DROP TABLE programmers;
DROP TABLE users;
DROP TABLE software_language;

-- Create software language table
CREATE TABLE software_language (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    name VARCHAR(64) NOT NULL,
    PRIMARY KEY (id)
);

-- Create user table
CREATE TABLE users (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    first_name VARCHAR (64) NOT NULL,
    last_name VARCHAR (64) NOT NULL,
    birth_date DATE NOT NULL,
    phone_number VARCHAR (32),
    email VARCHAR (128) NOT NULL
        CONSTRAINT email_format
            CHECK ( REGEXP_LIKE ( email, '^.+@.+$', 'i' ) ),
    password VARCHAR(255) NOT NULL,
    PRIMARY KEY (id),
    UNIQUE (email)
);

-- Create programmers table
CREATE TABLE programmers (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    user_id INTEGER NOT NULL,
    isAdmin CHAR DEFAULT '0' NOT NULL CHECK(isAdmin in ('0', '1')),
    PRIMARY KEY (id),
    FOREIGN KEY (user_id) REFERENCES users (id)
);

-- Create user - language table
CREATE TABLE user_language (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    user_id INTEGER NOT NULL,
    software_language_id INTEGER NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (user_id) REFERENCES users (id),
    FOREIGN KEY (software_language_id) REFERENCES software_language (id)
);

-- Create patch table
CREATE TABLE patches (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    creator_id INTEGER NOT NULL,
    release_date DATE DEFAULT NULL,
    deploy_date DATE DEFAULT NULL,
    approved CHAR DEFAULT '0' NOT NULL CHECK(approved in ('0', '1')),
    approved_programmer_id INTEGER DEFAULT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (approved_programmer_id) REFERENCES programmers (id),
    FOREIGN KEY (creator_id) REFERENCES users (id),
    CONSTRAINT check_approvee
        CHECK(approved in ('0') OR (approved in ('1') AND approved_programmer_id IS NOT NULL))
);

-- Create ticket table
CREATE TABLE tickets (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    state VARCHAR(12) DEFAULT 'CREATED' NOT NULL 
        CONSTRAINT state_format
            CHECK (state IN ('CREATED', 'IN_PROGRESS', 'DONE')),
    user_id INTEGER NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (user_id) REFERENCES users (id)
);

-- Create modul table
CREATE TABLE modules (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    name VARCHAR(128) NOT NULL,
    programmer_id INTEGER DEFAULT NULL, -- module moderator
    PRIMARY KEY (id),
    FOREIGN KEY (programmer_id) REFERENCES programmers (id)
);

-- Create module - language table
CREATE TABLE module_language (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    module_id INTEGER,
    software_language_id INTEGER,
    PRIMARY KEY (id),
    FOREIGN KEY (module_id) REFERENCES modules (id),
    FOREIGN KEY (software_language_id) REFERENCES software_language (id)
);

-- Create bug table
CREATE TABLE bugs (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    patch_id INTEGER DEFAULT NULL,
    finding_date DATE NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (patch_id) REFERENCES patches (id)
);

-- Create vulnerability table (bug can become potential vulnerability)
CREATE TABLE vulnerability (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY, -- Could be CVE ID
    confidentiality_score INTEGER DEFAULT 0, -- Impact Metrics
    integrity_score INTEGER DEFAULT 0,
    availability_score INTEGER DEFAULT 0,
    bug_id INTEGER NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (bug_id) REFERENCES bugs(id) ON DELETE CASCADE
);

-- Create ticket - bug table
CREATE TABLE ticket_bug (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    ticket_id INTEGER NOT NULL,
    bug_id INTEGER NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY(ticket_id) REFERENCES tickets (id),
    FOREIGN KEY(bug_id) REFERENCES bugs (id)
);

-- Create module - bug table
CREATE TABLE module_bug (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    module_id INTEGER NOT NULL,
    bug_id INTEGER NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (module_id) REFERENCES modules (id),
    FOREIGN KEY (bug_id) REFERENCES bugs (id)
);

-- Create patch - module table
CREATE TABLE patch_module (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    module_id INTEGER NOT NULL,
    patch_id INTEGER NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (module_id) REFERENCES modules (id),
    FOREIGN KEY (patch_id) REFERENCES patches (id)
);

-- Create bug message table
CREATE TABLE bug_message (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    created DATE NOT NULL,
    bug_id INTEGER NOT NULL,
    programmer_id INTEGER DEFAULT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (bug_id) REFERENCES bugs (id) ON DELETE CASCADE,
    FOREIGN KEY (programmer_id) REFERENCES programmers (id)
);

-- Create ticket - patch table
CREATE TABLE ticket_patch (
    id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    ticket_id INTEGER NOT NULL,
    patch_id INTEGER NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY (ticket_id) REFERENCES tickets (id),
    FOREIGN KEY (patch_id) REFERENCES patches (id)
);

-- Dummy data

-- Programming languages used
INSERT INTO software_language (name) VALUES ('Java');
INSERT INTO software_language (name) VALUES ('C');
INSERT INTO software_language (name) VALUES ('C++');
INSERT INTO software_language (name) VALUES ('Python');

-- Users
INSERT INTO users (first_name, last_name, birth_date, email, password)
VALUES('DummyName', 'DummySurname', TO_DATE('2000-01-01', 'yyyy/mm/dd'), 'DummyEmail@email.com', 'VeryLongLegitPasswordHash1');
INSERT INTO users (first_name, last_name, birth_date, email, password)
VALUES('DummyName1', 'DummySurname1', TO_DATE('2000-02-01', 'yyyy/mm/dd'), 'DummyEmail1@email.com', 'VeryLongLegitPasswordHash2');
INSERT INTO users (first_name, last_name, birth_date, email, password)
VALUES('DummyName2', 'DummySurname2', TO_DATE('2000-03-01', 'yyyy/mm/dd'), 'DummyEmail2@email.com', 'VeryLongLegitPasswordHash3');
INSERT INTO users (first_name, last_name, birth_date, email, password)
VALUES('DummyName3', 'DummySurname3', TO_DATE('2000-01-03', 'yyyy/mm/dd'), 'DummyEmail3@email.com', 'VeryLongLegitPasswordHash4');
INSERT INTO users (first_name, last_name, birth_date, email, password)
VALUES('DummyName4', 'DummySurname4', TO_DATE('2000-02-04', 'yyyy/mm/dd'), 'DummyEmail4@email.com', 'VeryLongLegitPasswordHash5');
INSERT INTO users (first_name, last_name, birth_date, email, password)
VALUES('DummyName5', 'DummySurname5', TO_DATE('2000-03-05', 'yyyy/mm/dd'), 'DummyEmail5@email.com', 'VeryLongLegitPasswordHash6');

-- 2 users are programmers
INSERT INTO programmers (user_id) VALUES (2);
INSERT INTO programmers (user_id, isAdmin) VALUES (3, '1');

-- Programming languages used by programmers
INSERT INTO user_language (user_id, software_language_id) VALUES(2, 1);
INSERT INTO user_language (user_id, software_language_id) VALUES(3, 2);
-- Programming languages used by users
INSERT INTO user_language (user_id, software_language_id) VALUES(4, 1);
INSERT INTO user_language (user_id, software_language_id) VALUES(5, 2);
INSERT INTO user_language (user_id, software_language_id) VALUES(6, 3);


-- Modules
INSERT INTO modules(name, programmer_id) VALUES('Main Framework', 1);
INSERT INTO modules(name) VALUES('Email Service');
INSERT INTO modules(name) VALUES('Web Service');

-- Languages used in modules
INSERT INTO module_language(module_id, software_language_id) VALUES(1, 1);
INSERT INTO module_language(module_id, software_language_id) VALUES(1, 3);
INSERT INTO module_language(module_id, software_language_id) VALUES(2, 4);
INSERT INTO module_language(module_id, software_language_id) VALUES(3, 3);

-- User 1 created a ticket
INSERT INTO tickets(user_id) VALUES(1);
-- Ticket contains information about 2 bugs
INSERT INTO bugs(finding_date) VALUES(TO_DATE('2022-01-01', 'yyyy/mm/dd'));
INSERT INTO bugs(finding_date) VALUES(TO_DATE('2022-01-01', 'yyyy/mm/dd'));
INSERT INTO ticket_bug(ticket_id, bug_id) VALUES(1, 1);
INSERT INTO ticket_bug(ticket_id, bug_id) VALUES(1, 2);
-- The bugs are in modules with ID 1 and 2
INSERT INTO module_bug(module_id, bug_id) VALUES (1, 1);
INSERT INTO module_bug(module_id, bug_id) VALUES (2, 2);
-- First bug is a vulnerability
INSERT INTO vulnerability(bug_id, confidentiality_score, integrity_score, availability_score) VALUES(1, 5, 5, 10);

-- Create bug messages. Programmer ID 1 moderates module ID 1
INSERT INTO bug_message(created, bug_id, programmer_id) 
VALUES(TO_DATE('2022-01-02', 'yyyy/mm/dd'), 1, 1);
INSERT INTO bug_message(created, bug_id) 
VALUES(TO_DATE('2022-01-02', 'yyyy/mm/dd'), 2);

-- Patches have been released and approved by programmer with ID 1
INSERT INTO patches(creator_id, release_date, approved, approved_programmer_id) 
VALUES(1, TO_DATE('2022-01-02', 'yyyy/mm/dd'), '1', 1);
INSERT INTO patches(creator_id, release_date, approved, approved_programmer_id) 
VALUES(1, TO_DATE('2022-01-02', 'yyyy/mm/dd'), '1', 1);

-- Ticket ID 1 is solved with patch 1 and 2
INSERT INTO ticket_patch(ticket_id, patch_id) VALUES(1, 1);
INSERT INTO ticket_patch(ticket_id, patch_id) VALUES(1, 2);

-- Modules ID 1 and 2 have been fixed with patches ID 1 and 2
INSERT INTO patch_module(module_id, patch_id) VALUES (1, 1);
INSERT INTO patch_module(module_id, patch_id) VALUES (2, 2);

-- Bugs ID 1 and 2 have been fixed using patches ID 1 and 2
UPDATE bugs SET patch_id=1 WHERE id=1; -- (not going to complicate this too much)
UPDATE bugs SET patch_id=2 WHERE id=2;


--------------------------------------------------------------------------------


-- Find email, first name and last name of all the programmers
SELECT email, first_name, last_name 
FROM users 
RIGHT JOIN programmers
ON users.id = programmers.user_id;

-- Find all bugs, which also contain vulnerabilities
SELECT bug_id, confidentiality_score, integrity_score, availability_score
FROM bugs INNER JOIN vulnerability
ON bugs.id = vulnerability.bug_id;

-- Find all modules which contain a bug, which is a vulnerability
-- (Bug isn't necessarily a vulnerability)
SELECT modules.name, vulnerability.bug_id
FROM modules
    INNER JOIN module_bug
    ON modules.id = module_bug.module_id
    INNER JOIN vulnerability
    ON module_bug.bug_id = vulnerability.bug_id;

-- How many users are using all the/specific programming language(s)
SELECT software_language.name, COUNT(software_language.id) AS "Used by"
FROM users 
    RIGHT JOIN user_language
    ON users.id = user_language.user_id
    LEFT JOIN software_language
    ON user_language.software_language_id = software_language.id
--WHERE software_language.name='C'
GROUP BY software_language.name;

-- How many programming languages does each module use
SELECT modules.name, COUNT(software_language.id) AS "Programming languages used"
FROM modules
    RIGHT JOIN module_language
    ON modules.id = module_language.module_id
    LEFT JOIN software_language
    ON module_language.software_language_id = software_language.id
GROUP BY modules.name;

-- Get all users that use some programming language
SELECT u.email, u.first_name, u.last_name
FROM users u
WHERE EXISTS (
    SELECT user_id
    FROM user_language ul
    WHERE u.id = ul.user_id
);

-- Find all tickets which were created by programmers
SELECT *
FROM tickets 
WHERE user_id IN (
    SELECT users.id
    FROM users 
        RIGHT JOIN programmers
        ON users.id = programmers.user_id
);
